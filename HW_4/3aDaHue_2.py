# Задайте натуральное число n.
# Напишите программу, которая составит список простых множителей числа n

# Асимпто́тика (гр.; см. асимптота) мат. поведение функции 
# в особых точках, чаще всего при стремлении аргумента или функции к бесконечности.

n = int(input('Введите какое-то натуральное число больше 3: '))
# Решето Эратосфена для нахождения простых чисел
# Решето Эратосфена — это алгоритм, позволяющий найти все
# простые числа в отрезке [1; n] за O (ln ln n) операций.
def primes(n):
    sieve = [True] * n
    for i in range(3, int(n**0.5)+1, 2):# (корень из (n) + 1) не повлияет на
                                        # асиптотику алгоритма, также ведём выборку 
                                        # по нечётным числам начиная с 3
        if sieve[i]:
            sieve[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)
            # Если выражение (n-i*i-1)//(2*i)+1 !=0, то срез с началом i*i::с шагом 2*i
            # будет возвращать список [False, False, ... , (n-i*i-1)//(2*i)+1 раз False]
            # т.е. список sieve[True]*n заполняется [False] в местах,
            # где не находятся простые числа
        return [2] + [i for i in range(3,n,2) if sieve[i]]
print(primes(n))

factors = []
d = 2
m = n               # Запомним исходное число
#while d * d <= n:  # Можно тоже самое проделать и через while
for d in primes(n + primes(n+3)[d]): # Но так, я думаю, эффективней
    if n == d:
        print('Это и есть простое число')
        exit()
    if not(n % d):
        factors.append(d)
        n//=d
    else:
        d += 1
factors.append(n)   # Добавим последнее простое число
print('{} равно произведению чисел {}'.format(m, factors))  # Выводим исходное число
                                                            # и все простые множители.